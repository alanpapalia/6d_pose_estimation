#include <Eigen/Dense>
#include <gflags/gflags.h>
#include <glog/logging.h>
#include <HFTrain.h>
#include <HFTest.h>
#include <boost/algorithm/string.hpp>
#include "opencv2/opencv.hpp"

using namespace cv;



DEFINE_bool(train, false, "Train a forest");
DEFINE_bool(test, false, "Test image of folder");
DEFINE_bool(learn_transitions, false, "Learn transitions between leaf nodes of a forest");
DEFINE_bool(save_forest_map, false, "Save map from poses to leaf ids");
DEFINE_string(input, "", "Input file containing training vectors from patches forwarded to the Deep Net");
DEFINE_string(output, ".", "Set output folder of the forest" );
DEFINE_int32(trees, 3, "Set Number of trees. Default: 3");
DEFINE_int32(min_samples, 30, "Set minimum samples of nodes");
DEFINE_int32(tests_per_node, 30, "Random tests per node");
DEFINE_int32(thresholds_per_test, 10, "Random thresholds per test");
DEFINE_int32(threads_per_tree, 8, "Set number of CPU cores per tree. Usually above 8 there is no speedup, use the rest for parallel trees.");
DEFINE_int32(threads_for_parallel_trees, 1, "Set number of parallel trees. Total threads is threads_per_tree * threads_per_parallel_trees");
DEFINE_int32(start_tree_no, 0, "Start tree number X, i.e. treeX.dat");

DEFINE_int32(patch_size_in_voxels, -1, "Patch Size in Voxels used in Patch extraction");
DEFINE_double(voxel_size_in_m, -1, "Voxel size in meters, used in Patch extraction");

DEFINE_string(detector_options_file, "", "Filename containing the detector options. Automatically generated by the generate_scripts.sh");
DEFINE_string(output_folder, "./results/", "Output folder to save the results of the test images");

// debugging
DEFINE_bool(show_scene, false, "Show the clustered scene with the plane removed if the option is set");
DEFINE_bool(visualize_hypotheses, false, "Show all hypotheses generated *for debugging*");

int main(int argc, char** argv)
{

    // Added here- Alan
    // Mat image;
    // image= cv::imread("~/Desktop/frame115.jpg");

    // // define bounding rectangle 
    // cv::Rect rectangle(50,70,image.cols-150,image.rows-180);

    // cv::Mat result; // segmentation result (4 possible values)
    // cv::Mat bgModel,fgModel; // the models (internally used)

    // // GrabCut segmentation
    // cv::grabCut(image,    // input image
    //                 result,   // segmentation result
    //                         rectangle,// rectangle containing foreground 
    //                         bgModel,fgModel, // models
    //                         1,        // number of iterations
    //                         cv::GC_INIT_WITH_RECT); // use rectangle
    // cout << "oks pa dito" <<endl;
    // // Get the pixels marked as likely foreground
    // cv::compare(result,cv::GC_PR_FGD,result,cv::CMP_EQ);
    // // Generate output image
    // cv::Mat foreground(image.size(),CV_8UC3,cv::Scalar(255,255,255));
    // image.copyTo(foreground,result); // bg pixels not copied

    // // draw rectangle on original image
    // cv::rectangle(image, rectangle, cv::Scalar(255,255,255),1);
    // cv::namedWindow("Image");
    // cv::imshow("Image",image);

    // // display result
    // cv::namedWindow("Segmented Image");
    // cv::imshow("Segmented Image",foreground);


    // waitKey();
    // // return 0;

    // End Added here - Alan
    


    google::InitGoogleLogging(argv[0]);

    #ifndef GFLAGS_GFLAGS_H_
      namespace gflags = google;
    #endif

    gflags::ParseCommandLineFlags(&argc, &argv, true);


    if(FLAGS_train){

        CHECK_GT(FLAGS_input.size(), 0) << "No input file specified";
        CHECK_GT(FLAGS_output.size(), 0) << "No output folder specified";
        CHECK_GT(FLAGS_trees, 0) << "You should train at least one tree";        
        CHECK_GT(FLAGS_min_samples, 0) << "min_samples should be greater than zero";
        CHECK_GT(FLAGS_tests_per_node, 0) << "There should be at least one test per node";
        CHECK_GT(FLAGS_thresholds_per_test, 0) << "There should be at least one threshold per test";
        CHECK_GT(FLAGS_threads_per_tree, 0) << "You should use at least one thread per tree";
        CHECK_GT(FLAGS_threads_for_parallel_trees, 0) << "You should use at least one thread for parallel trees";
        CHECK_GT(FLAGS_patch_size_in_voxels, 0) << "You should specify the Patch Size in Voxels (--patch_size_in_voxels)";
        CHECK_GT(FLAGS_voxel_size_in_m, 0) << "Shoud should specify the Voxel Size in Meters (--voxel_size_in_m)";
        HFTrain hf;
        hf.setNumTrees(FLAGS_trees);        
        hf.setMinSamples(FLAGS_min_samples);
        hf.setTestsPerNode(FLAGS_tests_per_node);
        hf.setThresPerTest(FLAGS_thresholds_per_test);
        hf.setInputPatchesFilename(FLAGS_input);
        hf.setOutputFolder(FLAGS_output);
        hf.setStartTreeNo(FLAGS_start_tree_no);
        hf.setNumberOfThreads(FLAGS_threads_per_tree, FLAGS_threads_for_parallel_trees);
        hf.setPatchSizeInVoxels(FLAGS_patch_size_in_voxels);
        hf.setVoxelSizeInM(FLAGS_voxel_size_in_m);
        hf.train();
    }

    else if(FLAGS_test){       

        HFTest ht;
        ht.DetectObjects();

    }

    return 0;
}
